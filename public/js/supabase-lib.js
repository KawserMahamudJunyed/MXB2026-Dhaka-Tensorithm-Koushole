!function (e, t) { "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).supabase = {}) }(this, (function (e) { "use strict"; var t = function (e, n) { return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t } || function (e, t) { for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]) }, t(e, n) }; function n(e, n) { if ("function" != typeof n && null !== n) throw new TypeError("Class extends value " + String(n) + " is not a constructor or null"); function r() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r) } var r = function () { return r = Object.assign || function (e) { for (var t, n = 1, r = arguments.length; n < r; n++)for (var i in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]); return e }, r.apply(this, arguments) }; function i(e, t, n, r) { return new (n || (n = Promise))((function (i, o) { function s(e) { try { u(r.next(e)) } catch (e) { o(e) } } function a(e) { try { u(r.throw(e)) } catch (e) { o(e) } } function u(e) { var t; e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function (e) { e(t) }))).then(s, a) } u((r = r.apply(e, t || [])).next()) })) } function o(e, t) { var n, r, i, o, s = { label: 0, sent: function () { if (1 & i[0]) throw i[1]; return i[1] }, trys: [], ops: [] }; return o = { next: a(0), throw: a(1), return: a(2) }, "function" == typeof Symbol && (o[Symbol.iterator] = function () { return this }), o; function a(o) { return function (a) { return function (o) { if (n) throw new TypeError("Generator is already executing."); for (; s;)try { if (n = 1, r && (i = 2 & o[0] ? r.return : o[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, o[1])).done) return i; switch (r = 0, i && (o = [2 & o[0], i.value]), o[0]) { case 0: case 1: i = o; break; case 4: return s.label++, { value: o[1], done: !1 }; case 5: s.label++, r = o[1], o = [0]; continue; case 7: o = s.ops.pop(), s.trys.pop(); continue; default: if (!(i = s.trys, i = i.length > 0 && i[i.length - 1]) && (6 === o[0] || 2 === o[0])) { s = 0; continue } if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) { s.label = o[1]; break } if (6 === o[0] && s.label < i[1]) { s.label = i[1], i = o; break } if (i && s.label < i[2]) { s.label = i[2], s.ops.push(o); break } i[2] && s.ops.pop(), s.trys.pop(); continue }o = arguments.length > 0 ? arguments[0] : void 0 } catch (e) { o = [6, e], r = 0 } finally { n = i = 0 } if (5 & o[0]) throw o[1]; return { value: o[0] ? o[1] : void 0, done: !0 } }([o, a]) } } } var s = "2.48.1"; const a = { getItem: e => { if ("undefined" == typeof document) return null; try { return window.localStorage.getItem(e) } catch (e) { throw console.error("Error getting data from localStorage", e), e } }, setItem: (e, t) => { if ("undefined" != typeof document) try { window.localStorage.setItem(e, t) } catch (e) { throw console.error("Error setting data to localStorage", e), e } }, removeItem: e => { if ("undefined" != typeof document) try { window.localStorage.removeItem(e) } catch (e) { throw console.error("Error removing data from localStorage", e), e } } }, u = () => !0; class c { constructor() { this.promise = new Promise(((e, t) => { this.resolve = e, this.reject = t })) } } function l(e) { var t; return null === (t = e.split(".").pop()) || void 0 === t ? void 0 : t.toLowerCase() } var h, d = function (e) { var t; return null === (t = e.name.split(".").pop()) || void 0 === t ? void 0 : t.toLowerCase() }; !function (e) { e.Aborted = "Aborted" }(h || (h = {})); const f = { getItem: (e, t) => { }, setItem: (e, t, n) => { }, removeItem: (e, t, n) => { } }; class p { constructor(e) { if (this.config = null, this.suppressGetSessionWarning = !1, this.lock = new c, this.locks = {}, this.onLockRelease = () => { }, this.config = e, this.checkConfig(), "undefined" != typeof window) { const e = this.config.storageKey, t = this.config.storage.getItem(e); t && this.config.storage.getItem(e.replace(".json", "")) && this.config.storage.removeItem(e.replace(".json", "")) } } checkConfig() { if (!this.config) throw new Error("Shared lock config is required"); if (!this.config.storageKey) throw new Error("Shared lock storage key is required"); if (!this.config.storage) throw new Error("Shared lock storage is required") } async acquireLock(e, t = 3e3, n = () => !0) { const r = this.config.storageKey; if (this.locks[e]) return new Promise(((e, t) => { e((async () => { throw new Error("Lock already acquired") })) })); let i = new c; return this.locks[e] = i, navigator.locks.request(e, t === 1 / 0 ? {} : { mode: "exclusive", ifAvailable: !0 }, ((o) => { if (o) { const s = new c; return this.locks[e] = s, i.resolve((async () => { if (!n()) throw new Error(h.Aborted); const i = this.config.storage.getItem(r); i && this.config.storage.setItem(r, JSON.stringify(Object.assign(Object.assign({}, JSON.parse(i)), { [e]: !0 }))); return async () => { const t = this.config.storage.getItem(r), n = t ? JSON.parse(t) : {}; delete n[e], this.config.storage.setItem(r, JSON.stringify(n)), delete this.locks[e], s.resolve(), this.onLockRelease() } })), s.promise } i.resolve((async () => { throw new Error(h.Aborted) })) })).catch((n => { if (n.message !== h.Aborted) throw n; return 0 === t || t === 1 / 0 ? new Promise(((e, t) => { e((async () => { const e = new Error(h.Aborted); throw e.name = h.Aborted, e })) })) : new Promise(((n, r) => { const i = setTimeout((() => { r(new Error("Acquiring lock timed out")) }), t); this.onLockRelease = () => { clearTimeout(i), this.acquireLock(e, t, (() => !1)).then(n, r) } })) })), i.promise } isLockAcquired(e) { const t = this.config.storageKey; try { const n = this.config.storage.getItem(t), r = n ? JSON.parse(n) : {}; return !!r[e] } catch (e) { return !1 } } releaseLock(e) { const t = this.config.storageKey; if (this.config.storage.getItem(t)) { const n = JSON.parse(this.config.storage.getItem(t)); delete n[e], this.config.storage.setItem(t, JSON.stringify(n)) } } } class g extends Error { constructor(e) { super(e), this.__isAuthError = !0, this.name = "AuthError" } } class y extends g { constructor(e, t) { super(e), this.name = "AuthApiError", this.status = t } toJSON() { return { name: this.name, message: this.message, status: this.status } } } class v extends g { constructor(e, t) { super(e), this.name = "AuthUnknownError", this.originalError = t } toJSON() { return { name: this.name, message: this.message, originalError: this.originalError } } } class m extends g { constructor(e, t, n) { super(e), this.name = t, this.status = n } toJSON() { return { name: this.name, message: this.message, status: this.status } } } function k(e) { return !(!e || "object" != typeof e || !("__isAuthError" in e)) } class w { constructor(e) { this.promise = new Promise(((t, n) => { this.resolve = t, this.reject = n })) } } function b(e) { const t = e.split("/"); return t[t.length - 1] } function _(e) { const t = e.split("."); return t[t.length - 1] } function S(e) { try { return JSON.parse(e) } catch (e) { return e } } function E(e) { const t = []; return e.forEach((e => { t.push(e) })), t } const P = 1e3; function x(e) { const t = e.split("."); if (3 !== t.length) throw new Error("JWT is not valid: not a JWT structure"); if (!/^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}=?$|[a-z0-9_-]{2}(==)?$)$/i.test(t[1])) throw new Error("JWT is not valid: payload is not a valid base64url string"); const n = t[1]; return JSON.parse(function (e) { const t = e.replace(/-/g, "+").replace(/_/g, "/"); switch (t.length % 4) { case 0: break; case 2: return atob(t + "=="); case 3: return atob(t + "="); default: throw "Illegal base64url string!" }try { return atob(t) } catch (e) { return atob(t) } }(n)) } async function T(e) { return await (new TextEncoder).encode(e) } async function A(e, t) { const n = await T(e), r = await T(t), i = await crypto.subtle.importKey("raw", r, { name: "HMAC", hash: "SHA-256" }, !1, ["sign"]), o = await crypto.subtle.sign("HMAC", i, n); return function (e) { var t, n, r = "", i = new Uint8Array(e), o = i.byteLength; for (t = 0; t < o; t++)r += (n = i[t], (n < 16 ? "0" : "") + n.toString(16)); return r }(o) } const C = "2.66.3", O = {}; class I { constructor(e) { this.url = e, this.headers = O } async _fetch(e) { const t = this._getFetchOptions(e); try { return await function (e, t) { return i(this, void 0, void 0, (function () { var n; return o(this, (function (r) { switch (r.label) { case 0: return [4, new Promise((function (t, n) { var r = new XMLHttpRequest; r.open(e.method, e.url), r.withCredentials = e.credentials, function (e, t) { Object.keys(t).forEach((function (n) { e.setRequestHeader(n, t[n]) })) }(r, e.headers), r.onload = function () { return t(r) }, r.onerror = function () { return n(new m("Network request failed", "TypeError", 0)) }, r.send(e.body) }))]; case 1: if (!((n = r.sent()).status >= 200 && n.status < 300)) throw n; "json" !== (t = t || {}).noResolveJson ? t.noResolveJson : t.noResolveJson; break; case 2: return [3, 4]; case 3: return r.sent(), [3, 4]; case 4: return [2, n] } })) })) }(t) } catch (e) { if (k(e)) throw e; throw new v(e.message, e) } } async _getFetchOptions(e) { var t, n; const r = { method: e.method, input: "", url: this.url }; return e.xform ? (r.url = e.xform(l), r.input = r.url) : r.url = l, r.body = e.body, r.headers = Object.assign({}, this.headers), e.jwt && (r.headers.Authorization = `Bearer ${e.jwt}`), Object.assign(Object.assign({}, r), e, ...e.body && { body: e.body }) } } const R = {}; class N { constructor(e) { this.url = e, this.headers = R } async _fetch(e) { const t = this._getFetchOptions(e); try { return await function (e, t) { return i(this, void 0, void 0, (function () { var n; return o(this, (function (r) { switch (r.label) { case 0: return [4, new Promise((function (t, n) { var r = new XMLHttpRequest; r.open(e.method, e.url), r.withCredentials = e.credentials, function (e, t) { Object.keys(t).forEach((function (n) { e.setRequestHeader(n, t[n]) })) }(r, e.headers), r.onload = function () { return t(r) }, r.onerror = function () { return n(new m("Network request failed", "TypeError", 0)) }, r.send(e.body) }))]; case 1: if (!((n = r.sent()).status >= 200 && n.status < 300)) throw n; "json" !== (t = t || {}).noResolveJson ? t.noResolveJson : t.noResolveJson; break; case 2: return [3, 4]; case 3: return r.sent(), [3, 4]; case 4: return [2, n] } })) })) }(t) } catch (e) { if (k(e)) throw e; throw new v(e.message, e) } } async _getFetchOptions(e) { var t, n; const r = { method: e.method, input: "", url: this.url }; return e.xform ? (r.url = e.xform(l), r.input = r.url) : r.url = l, r.body = e.body, r.headers = Object.assign({}, this.headers), e.jwt && (r.headers.Authorization = `Bearer ${e.jwt}`), Object.assign(Object.assign({}, r), e, ...e.body && { body: e.body }) } } class j { constructor() { this.promise = new Promise(((e, t) => { this.resolve = e, this.reject = t })) } } e.createClient = function (e, t, n) { return new function (e, t, n) { if (!e) throw new Error("supabaseUrl is required"); if (!t) throw new Error("supabaseKey is required"); const r = n ? Object.assign({}, n) : {}; return r.global = Object.assign(Object.assign({}, r.global), { headers: Object.assign(Object.assign({}, null === r || void 0 === r ? void 0 : r.global ? r.global.headers : null), { "X-Client-Info": "supabase-js-web/" + C }) }), r.auth = Object.assign(Object.assign({}, r.auth), { storage: a }), { auth: new I(e + "/auth/v1"), realtime: new N(e + "/realtime/v1"), db: new I(e + "/rest/v1"), storage: new I(e + "/storage/v1"), functions: new I(e + "/functions/v1"), global: r.global, shouldThrowOnError: r.shouldThrowOnError } }(e, t, n) }; Object.defineProperty(e, "__esModule", { value: !0 }) }));
